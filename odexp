#!/usr/bin/perl -w
#------------------------------------------------------------------------------
# File:         odexp
#
# Description:  parse/run a population dynamical system file   
#
# Revisions:    07/2018 - Samuel Bernard
#------------------------------------------------------------------------------

use warnings;
use strict;

my $version = '1.0';

use File::Copy;
use File::Basename qw( fileparse );
use File::Path qw( make_path );
use File::Spec;
use File::Temp qw/ tempfile tempdir /;

# ---------------------------------------
# regexp
# ---------------------------------------
my $re_iter_scalar = qr/
  \s*                   # whitespaces
  \[(\w+)               # iterator
  \s*                   
  =?               
  \s*     
  (|\d+)                 # start
  \s*:?\s*
  (|\d+)                 # end
  \]
/x;

my $re_iter = qr/
  \s*                   # whitespaces
  \[(\w+)               # iterator - mandatory
  \s*                   
  =                     # mandatory
  \s*     
  (\d+)                 # start - mandatory
  \s*:?\s*              # : mandatory
  (\d+)                 # end - mandatory
  \]
/x;

my $re_pace = qr/^
  \s*([%ACEIOPST])\w*   # type
  \s+                   # whitespaces
  (\w+)                 # varname 
  (?:\s*\[.*?\])*       # any number of brackets do not capture
  \s+                   # whitespace(s)
  ([^\{#\n]+)           # rhs until bracket comment or newline 
  (|\{.*?\})?           # nothing or attribute
  \s*                   # whitespace(s)
  (|\#.*)?              # nothing or comment
$/ix;

my $re_dxdt = qr/^
  \s*(D)                # first derivative
  (\w+)                 # var name
  (?:\s*\[.*?\])?       # optional brackets do not capture
  \/DT                  # second part of derivative
  \s*=\s*               # equal
  ([^\{#\n]+)           # rhs until bracket comment or newline 
  (|\{.*?\})?           # nothing or attribute
  \s*                   # whitespace(s)
  (|\#.*)?              # nothing or comment
$/ix;

my $re_pop = qr/^
  \s*(%\w*)             # type
  \s+                   # whitespace(s)
  ([^\{#\n]+)           # rhs until bracket comment or newline 
  (|\{.*?\})?           # nothing or attribute
  \s*                   # whitespace(s)
  (|\#.*)?              # nothing or comment
$/ix;

my $re_scalar = qr/^
      (?:D|\w+\s)               # starts with D or else
      \s*                       # whitespaces
      \w+(?:\s*\[\s*\d+\s*\])*  # varname followed by [0] optionally
      \s*                       # whitespaces
      (\/DT)?                   # followed by DT optionally
      \s*[^\[\S#\{]             # followed by something else that [, { or #
/ix;

# ---------------------------------------

my $odefilename;
# check the number of arguments, must be 1 or 2
my $nbr_argv = @ARGV;
if ( $nbr_argv == 0 ) {
  die "Require a filename";  
} else {
  $odefilename = $ARGV[0];
}

# ---------------------------------------
# Files created in .filebasename
# model.ode  model file where all constants are replaced by their values
# model.par contains parameter, initial condition, tspan and options
# model.c: C file implementation 
# ---------------------------------------

my $bname = fileparse($odefilename, qr/\.[^.]*/);
my $odedir = ".odexp";
if ( !-d $odedir & !-e $odedir ) {
  make_path $odedir or die  "Could not create directory $odedir. $!";
}

my $modelode = $odedir . "/model.ode";
my $modelc = $odedir . "/model.c";

open(my $fodeh, '>', $modelode) or die "Could not open file '$modelode'. $!";
print_ode_header();
cleanup_file($odefilename); # clean up ode filename
close $fodeh;

if ( $nbr_argv > 1 )
{
  copy($ARGV[1],$odedir . "/model.par") or die "Could not copy file '$ARGV[1]'. $!";
}
else
{
  copy($odedir . "/model.ode", $odedir . "/model.par") or die "Could not copy file '$odedir/model.ode'. $!";
}

# ====================================================================================
# Generate model.c
# ====================================================================================
open(my $fch, '>', $modelc) or die "Could not open file '$modelc'. $!";

print_c_header();
print $fch "/* Defines */\n\n";
set_defines($modelode);
print $fch "\n/* Global variables */\n\n";
# ====================================================================================
# DECLARE AND DEFINE CONSTANT ARRAYS
print $fch "/* Declaration and definition of constant arrays from files */\n";
declare_array_from_file($modelode);
declare_constant_array($modelode);
# ====================================================================================
# DECLARE AND DEFINE FUNCTIONS
define_functions($modelode);
# ====================================================================================
# Functions
declare_ode_functions();
# ====================================================================================
# Main 
print_main();
# ====================================================================================
# multiroots 
print_multiroots();
# ====================================================================================
# pop_rhs
print_pop_rhs();
# ====================================================================================
# pop_init_conditions
print_pop_init_conds();
# ====================================================================================
# ODE RHS
print_ode_rhs();
# ====================================================================================
# ODE INIT COND
print_ode_init_cond();

close $fch;

sub print_ode_header
{
  print $fodeh "# odexp file name: $ARGV[0]\n";
  print $fodeh "# In this file, all constant (variable starting with _)\n";
  print $fodeh "# are replaced with their value\n\n";
}

# strip any blank space at the beginning of a line
# append next line to all lines terminating with \
# append next line to all lines terminating with ... followed by any number of whitespaces
# replace all constants (variable starting with '_') by their value
# replace all , in P, O by \n 
sub cleanup_file
{
  my @underscores;
  my @usvals;
  my @declarations;
  my $tmpfh = tempfile(); # make a first pass in temp file to remove linebreaks
                          # and find underscores
  open(my $fh, '<', @_) or die "Could not open file '@_'. $!";
  while ( <$fh> )    
  {
    my @fields = split; 
    s/^[\ \t]+//;                     # trim space and tab at beginning of line
    s/\\\n$|\.\.\.\s*$//;             # continue line after \ or ...
    if ( /^_/ ) {
      push @underscores, $fields[0];
      push @usvals, join(' ',@fields[1..$#fields]);
      $usvals[$#usvals] =~ s/\s*?#.*?$//;
    }
    chomp if /,\s*$/;
    print $tmpfh "$_" ;
  }
  close($fh);
  seek $tmpfh, 0, 0; # rewind temp file to rebreak lines and replace underscores
  while ( <$tmpfh> )
  {
    my @fields = split; 
    foreach my $i ( 0..$#underscores )
    {
         s/(?<!^)$underscores[$i]/$usvals[$i]/g; # replace underscores that don't start a line
    }
    s/,/\n$fields[0] /g if /^[PO]/i;    # break lines at , and remove ,
    print $fodeh "$_";
  }
}

sub print_c_header 
{
  # Write C file header
  my $heading = qq(/* function implementations */

#ifndef __GNUC__
#  define  __attribute__(x)  /*NOTHING*/
#endif

/* Libraries */

#include <gsl/gsl_errno.h>
#include <gsl/gsl_vector.h>
#include <gsl/gsl_matrix.h>
#include <string.h>
#include <math.h>
#include <time.h>

/* Header files */

#include "odexp.h"

);
 
  print $fch $heading;

}

sub set_defines 
{
  open(my $fh, '<', @_) or die "Could not open file '@_'. $!";
  while (<$fh>) 
  {
    if ( my ($type, $varname, $rhs, $attr, $comment) = ( /$re_pace/ ) )
    {
      $type =~ /S/i or next; 
      $comment =~ s/#\s*//;
      print $fch "#define " . $varname . " " . $rhs;       
      print $fch " /* " . $comment . " */" if length $comment; 
      print $fch "\n";
    }
  }
  close($fh);
}


sub declare_array_from_file
{
  # expecting: F my_array_name nRow nCols filename.dat 
  open(my $fh, '<', @_) or die "Could not open file '@_'. $!";
  while (<$fh>) 
  {
    if ( /^[fF]/ )  
    {
      my @fields = split; 
      if ( 0+@fields < 5 ) { die "missing something at line: $_" };
      my ($var, $nbr_rows, $nbr_cols, $data_filename) = @fields[1..4];
      print $fch "/* array from file: $data_filename */\n";
      print $fch "static const double ${var}[$nbr_rows][$nbr_cols] = {";
      open(my $datafh, '<', $data_filename) or die "Could not open file '$data_filename'. $!";
      while( <$datafh> )
      {
          my @datafields = split;
          print $fch "{";
          for( my $j = 0; $j<$nbr_cols-1; ++$j )
          {
            print $fch "$datafields[$j], ";
          }
          if ( $. < $nbr_rows ) 
          {
            printf $fch "$datafields[$#datafields]},\\\n        "; 
          } else
          {
            printf $fch "$datafields[$#datafields]}}; /* source: $data_filename */\n\n";
          }
      }
      close($datafh);
    }
  }
  close($fh);
}

sub declare_constant_array
{
  # declare and initialize constant array
  open(my $fh, '<', @_) or die "Could not open file '@_'. $!";
  print $fch "/* Declaration and definition of constant arrays */\n\n";
  while (<$fh>) 
  {
    if ( /^[cC]/ )  
    {
      my @fields = split; 
      my $var = $fields[1];
      print $fch "static const double $var = " . join(' ', @fields[2..$#fields]) . ";\n\n";
    }
  }
  close($fh);
}

sub define_functions
{
  # declare and define user-defined functions
  open(my $fh, '<', @_) or die "Could not open file '@_'. $!";
  print $fch "/* Declaration and definition user-defined functions */\n\n";
  while (<$fh>) 
  {
    /^@/ or next;  
    my @fields = split /=/; 
    my @fs = split /[(,)@]/, shift(@fields);
    @fs = grep /\S/, @fs; # remove empty elements
    print $fch "double " . shift(@fs) . "(";
    while( @fs )
    {
      my $s = shift(@fs); # get next argument 
      $s =~ s/^\s*|\s*$//g; # trim whitespaces
      print $fch "double " . $s; 
      print $fch ", " if @fs;  # , only if not last argument
    }
    print $fch ")\n{\n";
    my @rhs = split /;|\(\{|\}\)/ , join('=', @fields);
    @rhs = grep /\S/, @rhs; # remove empty elements
    while ( @rhs )
    {
      my $s = shift(@rhs); 
      $s =~ s/^\s*|\s*$//g; # trim
      print $fch "    " . $s . ";\n" if @rhs; 
      print $fch "    return " . $s . ";\n" if not @rhs; 
    }
    print $fch "}\n\n";
  }
  close($fh);
   
}

sub declare_ode_functions
{
	# DECLARE ODE FUNCTIONS
  print $fch "/* Declaration and definition of functions */\n";
	my $s = qq(/* Functions */
int multiroot_rhs( const gsl_vector *x, void *params, gsl_vector *f);
int pop_rhs(double t, const double y[], double f[], void *params);
int ode_rhs(double t, const double y_[], double f_[], void *params);
int pop_init_conditions(const double t, double y[], void *params);
int ode_init_conditions(const double t, double y_[], void *params);

);
	print $fch $s;
}

sub print_main
{
	my $s = qq(int main ( int argc, char *argv[] )
{
    int status;

    if ( argc == 2 ) {
        status = odexp(pop_rhs, ode_rhs, pop_init_conditions, ode_init_conditions, multiroot_rhs,argv[1]);
    }
    else {
        status = odexp(pop_rhs, ode_rhs, pop_init_conditions, ode_init_conditions, multiroot_rhs,"unknown file name");
    }


    exit(EXIT_SUCCESS);
}

);
	print $fch $s;

}

sub print_multiroots
{
	my $s = qq(/* Wrapper function for ode_rhs. Modify at your own risks */
int multiroot_rhs( const gsl_vector *x, void *params, gsl_vector *f)
{
    double *y,*ff;
    size_t i;
    int ode_system_size = x->size;
    y = malloc(ode_system_size*sizeof(double));
    ff = malloc(ode_system_size*sizeof(double));
    for ( i = 0; i<ode_system_size; i++ )
    {
        y[i] = gsl_vector_get(x, i);
    }
    ode_rhs(0.0,y,ff,params);

    for ( i=0; i<ode_system_size; i++ )
    {
        gsl_vector_set(f, i, ff[i]);
    }

    free(y);
    free(ff);

    return GSL_SUCCESS;
}

);
	print $fch $s; 
}

sub print_pop_rhs
{
	my $s = qq(/* POP_RHS replicate ode_rhs pop_size times. y and f are array of size pop_size*ode_system_size */
int pop_rhs(double t, const double y[], double f[], void *params)
{
    clock_t start = clock();
    size_t i = 0, j;
    par *myself_ = SIM->pop->start;
    par *other_ = (par *)NULL;
    SIM->pop_birth_rate=0.0;
    for(j=0;j<SIM->nbr_mfd;j++)
    {
        SIM->meanfield[j] = 0.0;
    }
    while ( myself_ != NULL )
    {
        ode_rhs(t, y+i*myself_->nbr_y, f+i*myself_->nbr_y, myself_); /* first update myself_->aux, myself_->death_rate
                                                                      * first update myself_->repli_rate       */
);
	print $fch $s;
  set_population_birth_rate($modelode);
  $s = qq(        i++;
        myself_ = myself_->nextel;
    }
);
	print $fch $s;	
	set_population_meanfields($modelode);
  $s = qq(    for (j=0;j<SIM->nbr_mfd;j++)
    {
        SIM->meanfield[j] /= POP_SIZE;
    }
    SIM->pop_birth_rate /= POP_SIZE;
    myself_ = SIM->pop->start;
    i = 0;
    while ( myself_ != NULL )
    {
        /* update couplings if nbr_psi > 0 */
        if ( myself_->nbr_psi )
        {
            for(j=0;j<myself_->nbr_psi;j++)
            {
                myself_->psi[j] = 0.0;
            }
            other_ = SIM->pop->start;
            while ( other_ != NULL )
            {
);
	print $fch $s;	
	set_population_coupling($modelode);
  $s = qq(                other_ = other_->nextel;
            }
            for (j=0;j<myself_->nbr_psi;j++)
            {
                myself_->psi[j] /= POP_SIZE;
            }
        }
        ode_rhs(t, y+i*myself_->nbr_y, f+i*myself_->nbr_y, myself_);
        i++;
        myself_ = myself_->nextel;
    }

    SIM->time_in_ode_rhs += (clock()-start)*1000.0 / CLOCKS_PER_SEC;
    return GSL_SUCCESS;
}

);
	print $fch $s;	
}

sub set_population_birth_rate
{
  open(my $fh, '<', @_) or die "Could not open file '@_'. $!";
	while ( <$fh> )    
	{
		/^%BIRTH/i or next;
    my @fields = split;
    shift(@fields);
		print $fch "        SIM->pop_birth_rate += " . join(' ', @fields) . ";\n";
	}
	close($fodeh);
	
}

sub set_population_meanfields
{
	open(my $fh, '<', @_) or die "Could not open file '@_'. $!";
  my $nv=0;
	while ( <$fh> )    
	{
		/^%M/i or next;
    my ($type, $name, $rhs, $attr, $comment) = ( $_ =~ $re_pace );
    my $s = strip_blanks($rhs) . ";";
    $s .= " /* $attr */" if length $attr;
    $s .= " /* $comment */" if length $comment;
		print $fch "    myself_ = SIM->pop->start;\n";
		print $fch "    while ( myself_ != NULL )\n";
		print $fch "    {\n";
		print $fch "        SIM->meanfield[$nv] += $s\n"; 
    ++$nv;
 		print $fch "        myself_ = myself_->nextel;\n";
 		print $fch "    }\n";
	}
	close($fh);

}

sub set_population_coupling
{

  open(my $fh, '<', @_) or die "Could not open file '@_'. $!";
  my $nv=0;
	while ( <$fh> )    
	{
		/^%C/i or next;
    my ($type, $name, $rhs, $attr, $comment) = ( $_ =~ $re_pace );
    my $s = strip_blanks($rhs) . ";";
    $s .= " /* $attr */" if length $attr;
    $s .= " /* $comment */" if length $comment;
		print $fch "                myself_->psi[$nv] += $s\n";
		++$nv;
	}
	close($fodeh);
	
}

sub print_pop_init_conds
{
	my $s = qq(/* POP_INIT_CONDITIONS replicate ode_init_conditions pop_size times. y is an array of size pop_size*ode_system_size */
int pop_init_conditions(const double t, double y[], void *params)
{
    size_t i = 0, j;
    par *myself_ = SIM->pop->start;
    while ( myself_ != NULL )
    {
        ode_init_conditions(t, y+i*myself_->nbr_y, myself_);
        for(j=0;j<myself_->nbr_y;j++)
        {
            myself_->y[j] = *(y+i*myself_->nbr_y);
        }
        i++;
        myself_ = myself_->nextel;
    }

    return GSL_SUCCESS;
}

);
	print $fch $s;	
}

sub print_ode_rhs
{
	my $s = qq(/* this is the right-hand side of ODE system dy/dt = f(y,mu) for a single node */
int ode_rhs(double t, const double y_[], double f_[], void *params_)
{
    par *myself_ = (par *)params_;
    double * pars_ __attribute__((unused)) = SIM->mu;
    double * aux_  __attribute__((unused)) = myself_->aux;
    double * expr_ __attribute__((unused)) = myself_->expr;
    double * psi_  __attribute__((unused)) = myself_->psi;
    double * mfd_  __attribute__((unused)) = SIM->meanfield;

);
  print $fch $s;	
	declare_iterators($modelode);
  declare_define_parameters($modelode,"ode");  
  declare_scalar_or_array($modelode,"E","parametric expressions");
  declare_scalar_or_array($modelode,"%C","couplings");
  declare_scalar_or_array($modelode,"%M","mean fields");
  declare_scalar_or_array($modelode,"A","auxiliary functions");
  declare_scalar_or_array($modelode,"I","dynamical variables");
  define_array_from_input($modelode, "expr_", "E",
    qr/\w+\s+(\w+)/, 
    "initialization parametric expressions");
  define_array_from_input($modelode, "y_", "I",
    qr/\w+\s+(\w+)/, 
    "initialization dynamical variables");
  define_array_from_input($modelode, "psi_", "%C",
    qr/\w+\s+(\w+)/,
    "initialization couplings");
  define_array_from_input($modelode, "mfd_", "%M",
    qr/\w+\s+(\w+)/,
    "initialization meanfields");
  define_array_functions($modelode,
    "A", qr/^[aA]\s+(\w+)(\[[^\[\]]+\])*\s+(.*)$/,
    "initialization auxiliary functions");
  assign_output($modelode,
    "D", "f_", $re_dxdt,
    "assign equations FIXME", "rhs");
  assign_output($modelode,
    "A", "aux_", $re_pace, 
    "assign auxiliary array pointer", "pointer");
  assign_pop_rate($modelode,
    "%DEATH", "myself_->death_rate",
    "assign particle death rate");
  assign_pop_rate($modelode,
    "%REPLI", "myself_->repli_rate",
    "assign particle replication rate");
  print $fch "\n    return GSL_SUCCESS;\n}\n\n";
}

sub print_ode_init_cond
{
  my $s = qq(int ode_init_conditions(const double t, double y_[], void *params_)
{
    par *myself_ = (par *)params_;
    double * pars_ __attribute__((unused)) = SIM->mu;
    double * aux_  __attribute__((unused)) = myself_->aux;
    double * expr_ __attribute__((unused)) = myself_->expr;
);
  print $fch $s;
  declare_iterators($modelode);
  declare_define_parameters($modelode,"ic");  
  declare_scalar_or_array($modelode,"E","parametric expressions");
  define_array_functions($modelode,
    "E", qr/^[eE]\w*\s+(\w+)(\[[^\[\]]+\])*\s+(.*)$/,
    "initialization parametric expressions");
  assign_output($modelode,
    "E", "expr_", $re_pace,
    "assign parametric expression pointer", "rhs");
  assign_output($modelode,
    "I", "y_", $re_pace,
    "assign initial conditions", "rhs");
  print $fch "\n    return GSL_SUCCESS;\n}\n\n";
}

# declare_iterators
# search for iterators [i=0:10]
# and declare a list of unique iterators
#   size_t i,j,k;
sub declare_iterators
{
	print $fch qq(    /* iterators */
);
	open(my $fh, '<', @_) or die "Could not open file '@_'. $!";
  my @iterators;
  my @unique_iters;
	while ( <$fh> )    
	{
		!/^#/  or next; # ignore lines starting with '#'
		!/^C/i or next; # ignore lines starting with 'C'
    if ( my @new_iter = (/\[\s*(\w+)\s*=\s*\d+\s*:\s*\d+\s*\]+/g)  )
    {
      push @iterators, @new_iter; # store iterator name
    } else 
    {
      next;
    }
	}
	@iterators = sort @iterators;
	my $iter = shift @iterators;
  push @unique_iters, $iter if length $iter;
  while ( @iterators )
 	{
		$iter = shift @iterators;
		push @unique_iters, $iter if $unique_iters[$#unique_iters] ne $iter;
	}
  if ( 0+@unique_iters )
  {
	  print $fch "    size_t " . join(', ', @unique_iters) . ";\n";
  }
  print $fch "\n";
}

# declare_define_parameters
# take a line of the form 
#   P mu VAL {attr} # comment
# and write model.c 
#   double mu = par_[<i>]; /* attr */ /* comment */
sub declare_define_parameters
{
  my ($fname,$func) = @_;
  print $fch "    /* parameters */\n";
	open(my $fh, '<', $fname) or die "Could not open file '$fname'. $!";
  my $i = 0;
	while ( <$fh> )    
	{
  	/^P/i or next;
    if ( my ($type, $varname, $rhs, $attr, $comment) = ( /$re_pace/ ) )
    {
      if ( $func =~ /ode/ )
      {
        if ($attr =~ /\bINIT/i or
            $attr =~ /\bUNUSED/i or
            $attr =~ /\bINEXPR/i or 
            $attr =~ /\bPOP/i )	
        {
          ++$i;
        } else
        {
          print $fch "    double $varname = pars_[$i];";
          print $fch " /* $attr */" if length $attr;
          print $fch " /* $comment */" if length $comment; 
          print $fch "\n";
          ++$i;
        }
      } else
      {
        if ($attr =~ /\bINIT/i or
            $attr =~ /\bINEXPR/i or
            $attr =~ /\bEVER/i )	
        {
          print $fch "    double $varname = pars_[$i];";
          print $fch " /* $attr */" if length $attr;
          print $fch " /* $comment */" if length $comment; 
          print $fch "\n";
          ++$i;
        } else
        {
          ++$i;
        }
      }
    }
	}
  print $fch "\n";
  close($fh);
}

# TODO: handle definition of array in multiple declarations 
# declare_scalar_or_array
# takes a line E array[i=0:10][j=0:15]
# and declare
#   double array[10][15];
sub declare_scalar_or_array
{
  my ($fname,$character,$descr) = @_;
  print $fch "    /* $descr */\n";
  open(my $fh, '<', $fname) or die "Could not open file '$fname'. $!";
  while ( <$fh> )    
 	{
		/^$character/i or next;   # match character or go to next line of file
    my ($type, $name, $rhs, $attr, $comment) = ( $_ =~ $re_pace );
    print $fch "    double $name";
    if ( my @it = ($_ =~ m/$re_iter/g) )
    {
      while ( @it )
      {
        shift @it; shift @it; 
        my $b = shift @it;
        print $fch "[$b]";
      }
    }     
    print $fch ";\n";
	}	
  print $fch "\n";
  close($fh);
}

sub define_array_from_input
{
  my ($fname,$rhs,$pat_char,$pat_name,$descr) = @_;
  open(my $fh, '<', $fname) or die "Could not open file '$fname'. $!";
  print $fch "    /* $descr */\n";
  my $ii = 0;
  while ( <$fh> )    
  {
    /^$pat_char/i or next;
    my ($type, $name, $dummy, $attr, $comment) = ( $_ =~ $re_pace ) or print "no pace found";  
    if ( my @it = ($_ =~ m/$re_iter/g) )
    {
      my $offset = qq();
      my $j = 0;
      while ( $j < (0+@it) )
      {
        my ($i, $a, $b) = @it[$j..$j+2];
        $j += 3;
        $offset = $offset . qq(    ); 
        print $fch $offset . "for($i=$a;$i<$b;++$i)\n";
        print $fch $offset . "{\n";
      }
      print $fch $offset . "    $name";
      $j = 0;
      while ( $j < (0+@it) )
      {
        my ($i, $a, $b) = @it[$j..$j+2];
        $j += 3;
        print $fch "[$i]";
      }
      print $fch " = " . $rhs. "[$ii";
      my $starp = qq( + );
      my $iter_increment = 1;
      $j = 0;
      while ( $j < 0+@it )
      {
        my ($i, $a, $b) = @it[$j..$j+2];
        $j += 3;
        print $fch "$starp$i";
        $iter_increment *= ($b-$a);
        $starp = qq/*(1+/;
      }
      print $fch qq/)/ x (@it/3-1);
      print $fch "];"; 
      print $fch " /* $attr */" if length $attr;
      print $fch " /* $comment */" if length $comment;
      print $fch "\n";
      $ii += $iter_increment;
      $j = 0;
      while ( $j < 0+@it )
      {
        print $fch $offset . "}\n";
        $offset = substr $offset, 0, -4;
        $j += 3;
      }
    } else
    {
      print $fch "    $name = $rhs" . "[$ii];\n";
      ++$ii;
    }
  }
  print $fch "\n";
  close($fh);
}

sub define_array_functions
{
  my ($fname,$pat_char,$pat_nameiter,$descr) = @_;
  open(my $fh, '<', $fname) or die "Could not open file '$fname'. $!";
  print $fch "    /* $descr */\n";
  while ( <$fh> )    
  {
    /^$pat_char/i or next;
    my ($type, $name, $rhs, $attr, $comment) = ( $_ =~ $re_pace );
    my $rhs2print;
    $rhs2print = strip_blanks($rhs) . ";";
    $rhs2print .= " /* $attr */" if length $attr;
    $rhs2print .= " /* $comment */" if length $comment;
    if ( my @it = ($_ =~ m/$re_iter/g) )
    {
      my $offset = qq();
      my $j = 0;
      while ( $j < (0+@it) )
      {
        my ($i, $a, $b) = @it[$j..$j+2];
        $j += 3;
        $offset = $offset . qq(    ); 
        print $fch $offset . "for($i=$a;$i<$b;++$i)\n";
        print $fch $offset . "{\n";
      }
      print $fch $offset . "    $name";
      $j = 0;
      while ( $j < (0+@it) )
      {
        my ($i, $a, $b) = @it[$j..$j+2];
        $j += 3;
        print $fch "[$i]";
      }
      print $fch " = " . $rhs2print . "\n";
      $j = 0;
      while ( $j < 0+@it )
      {
        print $fch $offset . "}\n";
        $offset = substr $offset, 0, -4;
        $j += 3;
      }
    } else
    {
      print $fch "    $name = $rhs2print\n";
    }
  }
  print $fch "\n";
  close($fh);
  
}


sub assign_output 
{

  my ($fname,$pat_char,$lhs,$pat_nameiter,
    $descr,$assign_rhs) = @_;
  open(my $fh, '<', $fname) or die "Could not open file '$fname'. $!";
  print $fch "    /* $descr */\n";
  my $ii = 0;
  while ( <$fh> )    
  {
    /^$pat_char/i or next;
    my ($type, $name, $rhs, $attr, $comment) = ( $_ =~ $pat_nameiter );
    my $rhs2print;
    if ($assign_rhs =~ /rhs/)
    {
      $rhs2print = strip_blanks($rhs) . ";";
      $rhs2print .= " /* $attr */" if length $attr;
      $rhs2print .= " /* $comment */" if length $comment;
    } else 
    {
      $rhs2print = $name;
    }
    if ( $_ =~ m/$re_scalar/ ) # scalar variable
    {
      print $fch "    ${lhs}[$ii] = " . $rhs2print;
      print $fch ";" if $assign_rhs !~ /rhs/;
      print $fch "\n";
      ++$ii if /^(?:D|\w+\s)\s*(\w+\s*(\/DT)?\s*[^\[])/i;
      next;
    }
    if ( my @it = ($_ =~ m/$re_iter/g) )
    { 
      my $offset = qq();
      my $starp = qq( + );
      my $iter_increment = 1;
      my $j = 0;
      while ( $j < (0+@it) )
      {
        # $iter =~ /\s*(\w+)\s*=\s*(\d+)\s*:\s*(\d+)/;
        my ($i, $a, $b) = @it[$j..$j+2];
        $j += 3;
        $offset = $offset . qq(    ); 
        print $fch $offset . "for($i=$a;$i<$b;++$i)\n";
        print $fch $offset . "{\n";
      }
      print $fch $offset . "    ${lhs}[$ii";
      $j = 0;
      while ( $j < 0+@it )
      {
        my ($i, $a, $b) = @it[$j..$j+2];
        $j += 3;
        print $fch "$starp$i";
        $iter_increment *= ($b-$a);
        $starp = qq/*(1+/;
      }
      print $fch qq/)/ x (@it/3-1);
      print $fch "] = $rhs2print"; 
      $ii += $iter_increment;
      if ( $assign_rhs !~  /rhs/ )
      {
        $j = 0;
        while ( $j < 0+@it )
        {
          my ($i, $a, $b) = @it[$j..$j+2];
          $j += 3;
          print $fch "[$i]";
        }
        print $fch ";"; 
      }
      print $fch "\n";
      $j = 0;
      while ( $j < 0+@it )
      {
        print $fch $offset . "}\n";
        $offset = substr $offset, 0, -4;
        $j += 3;
      }
      print $fch "\n";
    }
  }
  print $fch "\n";
  close($fh);
}

sub assign_pop_rate
{
  my ($fname,$pat_char,$lhs,$descr) = @_;
  open(my $fh, '<', $fname) or die "Could not open file '$fname'. $!";
  print $fch "    /* $descr */\n";
  while ( <$fh> )    
  {
    /^$pat_char/i or next;
    if ( my ($type, $rhs, $attr, $comment) = ( /$re_pop/ ) )
    {
      print $fch "    $lhs = " . $rhs . ";"; 
      print $fch " /* $attr */" if length $attr;
      print $fch " /* $comment */" if length $comment;
      print $fch "\n";
    }
  }
  close($fh);
}

sub strip_blanks
{
  my ($str) = @_; 
  $str =~ s/^\s*//;
  $str =~ s/\s*$//;
  return $str;
}

my $LDFLAGS = "-lgsl -lodexp";
my $CFLAGS =  "-Wall -Wno-gnu-statement-expression -pedantic -g";
system("gcc $CFLAGS $LDFLAGS $odedir/model.c -o model.out") == 0 
              or die "compiling failed: $?";
exec ("./model.out $odefilename") or print STDERR "couldn't exec model.out: $!";


