#!/usr/bin/perl -w
#------------------------------------------------------------------------------
# File:         odexp
#
# Description:  parse/run a population dynamical system file   
#
# Revisions:    05/2019 - Samuel Bernard
#------------------------------------------------------------------------------

use warnings;
use strict;
use feature 'unicode_strings';

my $version = '1.0';

use File::Copy;
use File::Basename qw( fileparse );
use File::Path qw( make_path );
use File::Spec;
use File::Temp qw/ tempfile tempdir /;
use Getopt::Std;

# ---------------------------------------
# regexp
# ---------------------------------------
# valid identifiers start with a letter (Latin or Greek), and followed by 'word'
# characters: alphanumeric characters, underscore _, or Greek letters.
my $re_identifier = qr/[\p{L}Α-Ωα-ω][\wΑ-Ωα-ω]*/;
my $re_iter_scalar = qr/
  \s*                   # whitespaces
  \[(\w+)               # iterator
  \s*                   
  =?               
  \s*     
  (|\d+)                 # start
  \s*:?\s*
  (|\d+)                 # end
  \]
/x;

my $re_iter = qr/
  \s*                   # whitespaces
  \[(\w+)               # iterator - mandatory
  \s*                   
  =                     # mandatory
  \s*     
  (\d+)                 # start - mandatory
  \s*:?\s*              # : mandatory
  (\d+)                 # end - mandatory
  \]
/x;

my $re_pace = qr/^
  \s*(%|AUX|CONST|EXPR|INIT|OPT|PAR|MAC|TIMES|)\w*   # type
  \s+                   # whitespaces
  ($re_identifier)      # varname 
  (?:\s*\[.*?\])*       # any number of brackets do not capture
  \s+                   # whitespaces
  ([^\{#\n]+)           # rhs until bracket comment or newline 
  (|\{.*?\})?           # nothing or attribute
  \s*                   # whitespaces
  (|\#.*)?              # nothing or comment
$/ix;

my $re_nakedpar = qr/^
  \s*$re_identifier     # varname 
  \s+                   # whitespaces
  [-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)? # one number
  \s+                   # whitespace(s)
  (|\{.*?\})?           # nothing or attribute
  \s*                   # whitespace(s)
  (|\#.*)?              # nothing or comment
$/ix;                   # end of line

my $re_implicitIC = qr/^
  \s*PAR\w*             # must be a parameter
  \s+                   # whitespaces
  ($re_identifier)_0         # with a varname ends with _0
  \s+                   # whitespaces
  [-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)? # one number
  \s+                   # whitespace(s)
  (|\{.*?\})?           # nothing or attribute
  \s*                   # whitespace(s)
  (|\#.*)?              # nothing or comment
$/ix;                   # end of line

my $re_nakedaux = qr/^
  \s*($re_identifier    # varname 
  (?:\s*\[.*?\]+)?)     # optional brackets
  \s*                   # whitespaces
  =                     # equal sign
  \s*                   # whitespace
  ([^\{#\n]+)           # rhs until bracket comment or newline 
  (|\{.*?\})?           # nothing or attribute
  \s*                   # whitespace(s)
  (|\#.*)?              # nothing or comment
$/ix;                   # end of line

my $re_attributeIC = qr/^
  \s*D                  # first derivative
  ($re_identifier       # var name
  (?:\s*\[.*?\])?)      # optional brackets
  \/DT                  # second part of derivative
  \s*=\s*               # equal
  [^\{#\n]+             # rhs until bracket comment or newline 
  \{.*?init\s*=\s*(.*?)(?:;.*?\}|\s*\}) # attribute containing init=ic;
  \s*                   # whitespace(s)
  (?:|\#.*)?            # nothing or comment
$/ix;

my $re_lag = qr/^
  \s*L(?:AG)?           # lag keyword
  \s+                   # whitespaces
  ($re_identifier)      # varname
  \s*                   # whitespaces
  \{(.*?)\}             # mandatory attribute
  \s+                   # whitespaces
  (?:|\#.*)?            # nothing or comment
$/ix;

my $re_dxdt = qr/^
  \s*(D)                # first derivative
  ($re_identifier)      # var name
  (?:\s*\[.*?\])?       # optional brackets do not capture
  \/DT                  # second part of derivative
  \s*=\s*               # equal
  ([^\{#\n]+)           # rhs until bracket comment or newline 
  (|\{.*?\})?           # nothing or attribute
  \s*                   # whitespace(s)
  (|\#.*)?              # nothing or comment
$/ix;

my $re_pop = qr/^
  \s*(%\w*)             # type
  \s+                   # whitespace(s)
  ([^\{#\n]+)           # rhs until bracket comment or newline 
  (|\{.*?\})?           # nothing or attribute
  \s*                   # whitespace(s)
  (|\#.*)?              # nothing or comment
$/ix;

my $re_lrexp = qr/^
\s*%C                 # expansion keyword
  \s+                   # whitespaces
  ($re_identifier)      # varname
  \s+                   # whitespaces
  ([^\{#\n]+)           # rhs until bracket comment or newline 
  \{(.*?)\}             # mandatory attribute
  \s+                   # whitespaces
  (?:|\#.*)?            # nothing or comment
$/ix;

my $re_scalar = qr/^
      (?:D|\w+\s)               # starts with D or else
      \s*                       # whitespaces
      $re_identifier(?:\s*\[\s*\d+\s*\])*  # varname followed by [0] optionally
      \s*                       # whitespaces
      (\/DT)?                   # followed by DT optionally
      \s*[^\[\S#\{]             # followed by something else that [, { or #
/ix;

# ---------------------------------------

# odexp optional parameters
our ($opt_p, $opt_o, $opt_i);
$opt_i = 0; # default: do check for syntax error 
getopts('o:p:i'); # -o optimization; -p parameterfilename; -i do not check for syntax errors
if ( !defined $opt_o )
{
    $opt_o = 'g';
}
my $odefilename;
# check the number of arguments, must be 1 or 2
my $nbr_argv = @ARGV;
if ( $nbr_argv == 0 ) {
  $odefilename = "stdinput";
} else {
  $odefilename = $ARGV[0];
}

# ---------------------------------------
# Files created in .odexp
# equations.pop:   equation, constants, datafile ... where all constants are replaced by their values
# parameters.pop:  contains parameter, initial condition, tspan and options
# model.c:         C file implementation 
# ---------------------------------------

my $bname = fileparse($odefilename, qr/\.[^.]*/);
my $odedir = ".odexp";
if ( !-d $odedir & !-e $odedir ) {
  make_path $odedir or die  "Could not create directory $odedir. $!";
}

my $modelode = $odedir . "/equations.pop";
my $modelc = $odedir . "/model.c";

open(my $fodeh, '>', $modelode) or die "Could not open file '$modelode'. $!";
print_ode_header();
cleanup_file(); # clean up ode 
close $fodeh;

guess_single_popmode($modelode);

if ( defined $opt_p )
{
  copy($opt_p,$odedir . "/parameters.pop") or die "Could not copy file '$opt_p'. $!";
}
else
{
  copy($odedir . "/equations.pop", $odedir . "/parameters.pop") or die "Could not copy file '$odedir/equations.pop'. $!";
}


# ====================================================================================
# Generate model.c
# ====================================================================================
open(my $fch, '>', $modelc) or die "Could not open file '$modelc'. $!";

# ====================================================================================
# Try to find author information 
# ====================================================================================
#find_authors($modelode);

# ====================================================================================
# Print Header 
# ====================================================================================
print_c_header();
print $fch "/* Defines */\n\n";
set_defines($modelode);
print $fch "\n/* Global variables */\n\n";
# ====================================================================================
# DECLARE AND DEFINE CONSTANT ARRAYS
print $fch "/* Declaration and definition of constant arrays from files */\n";
declare_array_from_file($modelode);
declare_constant_array($modelode);
# ====================================================================================
# DECLARE AND DEFINE FUNCTIONS
define_functions($modelode);
# ====================================================================================
# Functions
declare_ode_functions();
# ====================================================================================
# Main 
print_main();
# ====================================================================================
# multiroots 
print_multiroots();
# ====================================================================================
# pop_rhs
print_pop_rhs();
# ====================================================================================
# pop_init_conditions
print_pop_init_conds();
# ====================================================================================
# ODE RHS
print_ode_rhs();
# ====================================================================================
# ODE INIT COND
print_ode_init_cond();

close $fch;

sub print_ode_header
{
  print $fodeh "# odexp file name: $odefilename\n";
  print $fodeh "# In this file, predefined constants (with keyword SET)\n";
  print $fodeh "# are replaced with their value\n\n";
}

# strip any blank space at the beginning of a line
# append next line to all lines terminating with \
# append next line to all lines terminating with ... followed by any number of whitespaces
# replace all SET constants by their value
# add PAR in front of each naked parameter (see $re_nakedpar)
# add INIT in front of each implicit IC, and remove the trailing _0 (see $re_implicitIC)
# parse IC in attribute (see $re_attributeIC)
# parse implicitly defined delayed variables (see $re_lag)
# replace all , in PAR, OPT by \n 
sub cleanup_file
{
  my @lets;
  my @letvals;
  my $tmpfh = tempfile(); # make a first pass in temp file to remove linebreaks
                          # and find lets
  my $funcdelimiter = 0;
  my $line_cont = 0; 
  my $in_fun = 0;
  while ( <> )    
  {
    if ( $opt_i == 0 )
    {
      # check for common syntax errors 
      /\{.*?unused.*?\}/ and die "error: change unused for impl on line ${.}.\n";
      /\{.*?pop.*?\}/ and die "error: change pop for impl on line ${.}.\n";
      /\{.*?inexpr.*?\}/ and die "error: change inexpr for init on line ${.}.\n";
      /(MU|ME|MA|MY|OE|OA|OY|MF)\(\"($re_identifier)\"\)/ and 
          die "error: macro $1 needs no quote around the variable '$2' on line ${.}. Try $1($2).\n";
      /^\s*(S|P|A|E|I|O|F|C)[ 0-9]/i and 
          die "error: incomplete keyword '$1' on line ${.}.\n" unless $in_fun;
      /^\s*@/ and die "error: @ is obsolete, use fun instead on line ${.}.\n";
      /^\s*($|#|PAR|EXPR|AUX|D|INIT|SET|MAC|TIME|OPT|FUN|CONST|FI|LAG|%M|%C|%BIRTH|%DEATH|%REPLI)/i
        or die "error: wrong keyword on line ${.}: $_" unless ($line_cont or $in_fun);
      if ( /\.\.\.\s*$/ ) 
        { $line_cont = 1; } 
      else  
        { $line_cont = 0; }
      $in_fun = 1 if  /^\s*fun/i;
      $in_fun = 0 if ( /^\s*end/i or /^\s*fun.*?=/i );
      # end check common errors
    }

    # reformat pop file    
    s/^\s+(\S)/$1/;                   # trim space and tab at beginning of line
    s/^([^#].*?)(\\\n$|\.\.\.\s*$)/$1/;    # join line after \ or ... if they are not only comments
    my @fields = split; 
    if ( /^SET/i ) {
      push @lets, $fields[1];
      push @letvals, join(' ',@fields[2..$#fields]);
      $letvals[$#letvals] =~ s/\s*?#.*?$//;
    }
    chomp if /^[^#].*?,\s*$/;                 # join lines if line ends with ,
    if ( /^@|^FUN/i && /\=/)  # this is a one liner function
    {
      s/\=/= return/;
    }
    if ( /^@|^FUN/i && not /\=/ )
    {
      $funcdelimiter = 1;
      s/\s*$/ = \n/;
    }
    $funcdelimiter = 0 if /^END/i;
    chomp if $funcdelimiter;                  # join lines within function 
    s/^END//i;                                 # remove the END
    print $tmpfh "$_";
  }
  #close($fh);
  seek $tmpfh, 0, 0; # rewind temp file to rebreak lines at ',' and replace lets
  print $fodeh "# begin of pop file entries vvvvvvvvvvvvvvvvvvvvvvvvv\n\n";
  while ( <$tmpfh> )
  {
    /$re_nakedpar/ && s/^\s*/PAR /;     # insert PAR before naked parameters
    if ( my ($varname) = ( $_ =~ /$re_nakedaux/ ) )
      {
        s/^\s*$varname\s*=/AUX $varname /;     # insert AUX before naked aux   
      }
    if ( my ($varname) = ( $_ =~ /$re_implicitIC/ ) )
      {
        s/$/\nINIT $varname ${varname}_0/;   # insert new line with initial condition  
      }
    if ( my ($varname, $ic) = ( $_ =~ /$re_attributeIC/ ) )
      {
        s/$/\nINIT $varname $ic/;   # insert new line with initial condition  
      }
    if ( my ($varname, $attr) = ( $_ =~ /$re_lag/ ) )
      {
        s/^/# /; # comment out the line
        my ($rootvar) = ( $attr =~ /root\s*=\s*(.*?)([;\s]|$)/ );
        my ($ic) = ( $attr =~ /init\s*=\s*(.*?)([;\s]|$)/ );
        my ($len) = ( $attr =~ /len\s*=\s*(.*?)([;\s]|$)/ );
        my ($mean) = ( $attr =~ /mean\s*=\s*(.*?)([;\s]|$)/ );
        s+$+\nd${varname}_chain[i=0:$len]/dt = linchaindelay($rootvar,${varname}_chain,i,$mean,$len) {hidden}\nmacro ${varname}_end $len-1\nAUX $varname ${varname}_chain[${varname}_end]\nINIT ${varname}_chain[i=0:$len] $ic {hidden}+; # insert new lines
      }
    my @fields = split; 
    foreach my $i ( 0..$#lets )
    {
      # s/(?<!^)$lets[$i]/$letvals[$i]/g; # replace lets that don't start a line
        s/\b$lets[$i]\b/$letvals[$i]/g unless /^SET/i; # replace lets that don't start a line
    }
    s/,/\n$fields[0] /g if /^(PAR|OPT)/i;    # break lines at , and remove , if line starts with P or O 
    print $fodeh "$_";
  }
  print $fodeh "# end of pop file entries ^^^^^^^^^^^^^^^^^^^^^^^^^\n\n";
}

sub guess_single_popmode
{
  open(my $fh, '<', @_) or die "could not open file '@_'. $!";
  my $pop_parameter_found = 0;
  my $popmode_option_found = 0;
  while (<$fh>) 
  {
    if ( my ($type) = ( $_ =~ /^%(BIRTH|DEATH|PROLIF|M|C)/i ) )
    {
      $pop_parameter_found = 1;
    }
    if ( my ($type,$varname) = ( $_ =~ /$re_pace/ )  )
    {
        $popmode_option_found = 1 if $varname =~ /(pm|popmode)/;
    }
  }
  close($fh);

  if ( ( $pop_parameter_found == 0 ) and ( $popmode_option_found == 0 ) )
  {
    open(my $fh, '>>', @_) or die "Could not open file '$modelode'. $!";
    print $fh "OPT popmode single # single mode looks appropriate here; option added automatically\n\n";
    close($fh);
  }
}

sub print_c_header 
{
  # Write C file header
  my $heading = qq(/* function implementations from file 
 * $odefilename 
 */

#ifndef __GNUC__
#  define  __attribute__(x)  /*NOTHING*/
#endif

/* Libraries */

#include <gsl/gsl_errno.h>
#include <gsl/gsl_vector.h>
#include <gsl/gsl_matrix.h>
#include <string.h>
#include <math.h>
#include <time.h>

/* Header files */

#include "odexp.h"

);
 
  print $fch $heading;

}

sub set_defines 
{
  open(my $fh, '<', @_) or die "could not open file '@_'. $!";
  while (<$fh>) 
  {
    if ( my ($type, $varname, $rhs, $attr, $comment) = ( /$re_pace/ ) )
    {
      $type =~ /^MAC/i or next; 
      $comment =~ s/#\s*//; # strip comment
      print $fch "#define " . $varname . " " . $rhs;       
      print $fch " /* " . $comment . " */" if length $comment; 
      print $fch "\n";
    }
  }
  close($fh);
}


sub declare_array_from_file
{
  # expecting: F my_array_name nRow nCols filename.dat 
  open(my $fh, '<', @_) or die "Could not open file '@_'. $!";
  while (<$fh>) 
  {
    if ( /^FI/i )  
    {
      my @fields = split; 
      if ( 0+@fields < 5 ) { die "missing something at line: $_" };
      my ($var, $nbr_rows, $nbr_cols, $data_filename) = @fields[1..4];
      print $fch "/* array from file: $data_filename */\n";
      print $fch "static const double ${var}[$nbr_rows][$nbr_cols] __attribute__((unused)) = {\n        ";
      open(my $datafh, '<', $data_filename) or die "Could not open file '$data_filename'. $!";
      while( <$datafh> )
      {
          my @datafields = split;
          print $fch "{";
          for( my $j = 0; $j<$nbr_cols-1; ++$j )
          {
            print $fch "$datafields[$j], ";
          }
          if ( $. < $nbr_rows ) 
          {
            printf $fch "$datafields[$#datafields]},\\\n        "; 
          } else
          {
            printf $fch "$datafields[$#datafields]}}; /* source: $data_filename */\n\n";
          }
      }
      close($datafh);
    }
  }
  close($fh);
}

sub declare_constant_array
{
  # declare and initialize constant array
  open(my $fh, '<', @_) or die "Could not open file '@_'. $!";
  print $fch "/* Declaration and definition of constant arrays */\n\n";
  while (<$fh>) 
  {
    if ( /^CONST/i )  
    {
      my @fields = split; 
      my $var = $fields[1];
      print $fch "static const double $var = " . join(' ', @fields[2..$#fields]) . ";\n\n";
    }
  }
  close($fh);
}

sub define_functions
{
  # declare and define user-defined functions
  open(my $fh, '<', @_) or die "Could not open file '@_'. $!";
  print $fch "/* Declaration and definition user-defined functions */\n\n";
  while (<$fh>) 
  {
    /^(@|FUN)/i or next;  
    my @fields = split;                         # split line by whitespace
    shift(@fields);                             # remove keyword @/fun
    @fields = split /=/, join(' ', @fields);    # resplit line by =
    my @fs = split /[(,)]/i, shift(@fields);    # split lhs 
    @fs = grep /\S/, @fs;                       # remove empty elements
    print $fch "double " . shift(@fs) . "(";    # print func name and (
    while( @fs )
    {
      my $s = shift(@fs);                       # get next argument 
      $s =~ s/^\s*|\s*$//g;                     # trim whitespaces
      if ( $s =~ /void|int|long|char|float/ )
      {
        print $fch $s;                          # print argument as is
      }
      else
      {
        print $fch "double " . $s;              # argument is double by default  
      }
      print $fch ", " if @fs;                   # , only if not last argument
    }
    print $fch ")\n{\n";
    my @rhs = split /;/ , join('=', @fields);   # put '=' back and split by ';' 
    @rhs = grep /\S/, @rhs; # remove empty elements
    while ( @rhs )                              # print all statements with ';'
    {
      my $s = shift(@rhs); 
      $s =~ s/^\s*|\s*$//g; # trim
      # print $fch "    " . $s . ";\n" if @rhs; 
      # print $fch "    return " . $s . ";\n" if not @rhs; 
      print $fch "    " . $s . ";\n"; 
    }
    print $fch "}\n\n";
  }
  close($fh);
   
}

sub declare_ode_functions
{
	# DECLARE ODE FUNCTIONS
  print $fch "/* Declaration and definition of functions */\n";
	my $s = qq(/* Functions */
int multiroot_rhs( const gsl_vector *x, void *params, gsl_vector *f);
int pop_rhs(double t, const double y_[], double f_[], void *params);
int ode_rhs(double t, const double y_[], double f_[], void *params);
int pop_init_conditions(const double t, double y_[], void *params);
int ode_init_conditions(const double t, double y_[], void *params);

);
	print $fch $s;
}

sub print_main
{
	my $s = qq(int main ( int argc, char *argv[] )
{
    odexp(pop_rhs, ode_rhs, pop_init_conditions, ode_init_conditions, multiroot_rhs,"$odefilename");

    exit(EXIT_SUCCESS);
}

);
	print $fch $s;

}

sub print_multiroots
{
	my $s = qq(/* Multiroot wrapper function for ode_rhs */
int multiroot_rhs( const gsl_vector *x, void *params, gsl_vector *f)
{
    double *y,*ff;
    size_t i;
    int ode_system_size = x->size;
    y = malloc(ode_system_size*sizeof(double));
    ff = malloc(ode_system_size*sizeof(double));
    for ( i = 0; i<ode_system_size; i++ )
    {
        y[i] = gsl_vector_get(x, i);
    }
    ode_rhs(0.0,y,ff,params);

    for ( i=0; i<ode_system_size; i++ )
    {
        gsl_vector_set(f, i, ff[i]);
    }

    free(y);
    free(ff);

    return GSL_SUCCESS;
}

);
	print $fch $s; 
}

sub print_pop_rhs
{
	my $s = qq(/* POP_RHS replicate ode_rhs pop_size times. y_ and f_ are array of size pop_size*ode_system_size */
int pop_rhs(double t, const double y_[], double f_[], void *params)
{
    clock_t start = clock();
    size_t i = 0, j;
    par *myself_ = SIM->pop->start;
    par __attribute__((unused)) *other_ = (par *)NULL;

    /* low-rank expansion */
    double __attribute__((unused)) *xxp_, *yxp_;
    /* low-rank expansion */

    SIM->pop_birth_rate=0.0;
    for(j=0;j<SIM->nbr_mfd;j++)
    {
        SIM->meanfield[j] = 0.0;
    }
    while ( myself_ != NULL )
    {
        ode_rhs(t, y_+i*myself_->nbr_y, f_+i*myself_->nbr_y, myself_); /* first update myself_->aux, myself_->death_rate
                                                                      * first update myself_->repli_rate       */
);
	print $fch $s;
  set_population_birth_rate($modelode);
  $s = qq(        i++;
        myself_ = myself_->nextel;
    }
);
	print $fch $s;	

  set_low_rank_expansion($modelode);

	set_population_meanfields($modelode);
  $s = qq(    SIM->pop_birth_rate /= POP_SIZE;
    myself_ = SIM->pop->start;
    i = 0;
    while ( myself_ != NULL )
    {
);
  print $fch $s;

  set_population_coupling($modelode);

  $s = qq(        ode_rhs(t, y_+i*myself_->nbr_y, f_+i*myself_->nbr_y, myself_);
        i++;
        myself_ = myself_->nextel;
    }

    SIM->time_in_ode_rhs += (clock()-start)*1000.0 / CLOCKS_PER_SEC;
    return GSL_SUCCESS;
}

);
	print $fch $s;	
}

sub set_population_birth_rate
{
  open(my $fh, '<', @_) or die "Could not open file '@_'. $!";
	while ( <$fh> )    
	{
		/^%BIRTH/i or next;
    my @fields = split;
    shift(@fields);
		print $fch "        SIM->pop_birth_rate += " . join(' ', @fields) . ";\n";
	}
	close($fodeh);
	
}

sub set_population_meanfields
{
	open(my $fh, '<', @_) or die "Could not open file '@_'. $!";
  my $nv=0;
	while ( <$fh> )    
	{
		/^%M/i or next;
    my ($type, $name, $rhs, $attr, $comment) = ( $_ =~ $re_pace );
    my $s = strip_blanks($rhs) . ";";
    $s .= " /* $attr */" if length $attr;
    $s .= " /* $comment */" if length $comment;
		print $fch "    myself_ = SIM->pop->start;\n";
		print $fch "    while ( myself_ != NULL )\n";
		print $fch "    {\n";
		print $fch "        SIM->meanfield[$nv] += $s\n"; 
 		print $fch "        myself_ = myself_->nextel;\n";
 		print $fch "    }\n";
    print $fch "    SIM->meanfield[$nv] /= POP_SIZE;\n";
    ++$nv;
	}
	close($fh);

}

sub set_population_coupling
{

  open(my $fh, '<', @_) or die "Could not open file '@_'. $!";
  my $nv=0;
  my $nbr_n2_coupling=0;
  
  while ( <$fh> )    
  {
		/^%C/i or next;
    my ($type, $name, $rhs, $attr, $comment) = ( $_ =~ $re_pace );
    $nbr_n2_coupling++ if $attr =! /lrw?exp/;
  }
  seek $fh, 0, 0; # rewind file 

  if ($nbr_n2_coupling > 0)
  {
    my $s = qq(        /* update coupling terms psi, O(N^2) */
        for(j=0;j<myself_->nbr_psi;j++)
        {
          myself_->psi[j] = 0.0;
        }
        other_ = SIM->pop->start;
        while ( other_ != NULL )
        {
);
    print $fch $s;	

    while ( <$fh> )    
    {
      /^%C/i or next;
      my ($type, $name, $rhs, $attr, $comment) = ( $_ =~ $re_pace );
      my $s = strip_blanks($rhs) . ";";
      $s .= " /* $attr */" if length $attr;
      $s .= " /* $comment */" if length $comment;
      print $fch "          myself_->psi[$nv] += $s\n";
      ++$nv;
    }
    $s = qq(          other_ = other_->nextel;
        }
        for (j=0;j<myself_->nbr_psi;j++)
        {
          myself_->psi[j] /= POP_SIZE;
        }
);
    print $fch $s;
  }
	close($fodeh);
	
}

sub print_pop_init_conds
{
	my $s = qq(/* POP_INIT_CONDITIONS replicate ode_init_conditions pop_size times. y_ is an array of size pop_size*ode_system_size */
int pop_init_conditions(const double t, double y_[], void *params)
{
    size_t i = 0, j;
    par *myself_ = SIM->pop->start;
    while ( myself_ != NULL )
    {
        ode_init_conditions(t, y_+i*myself_->nbr_y, myself_);
        for(j=0;j<myself_->nbr_y;j++)
        {
            myself_->y[j] = *(y_+i*myself_->nbr_y);
        }
        i++;
        myself_ = myself_->nextel;
    }

    return GSL_SUCCESS;
}

);
	print $fch $s;	
}

sub print_ode_rhs
{
	my $s = qq(/* this is the right-hand side of ODE system dy/dt = f(y,mu) for a single node */
int ode_rhs(double t, const double y_[], double f_[], void *params_)
{
    par *myself_ = (par *)params_;
    double * pars_ __attribute__((unused)) = SIM->mu;
    double * aux_  __attribute__((unused)) = myself_->aux;
    double * expr_ __attribute__((unused)) = myself_->expr;
    double * psi_  __attribute__((unused)) = myself_->psi;
    double * mfd_  __attribute__((unused)) = SIM->meanfield;
    double * f2_ = f_;

);
  print $fch $s;	
	declare_iterators($modelode);
  declare_define_parameters($modelode,"ode");  
  declare_scalar_or_array($modelode,"EXPR","parametric expressions");
  declare_scalar_or_array($modelode,"%C","couplings");
  declare_scalar_or_array($modelode,"%M","mean fields");
  declare_scalar_or_array($modelode,"AUX","auxiliary functions");
  declare_scalar_or_array($modelode,"INIT","dynamical variables");
  define_array_from_input($modelode, "expr_", "EXPR",
    qr/\w+\s+(\w+)/, 
    "initialization parametric expressions");
  define_array_from_input($modelode, "y_", "I",
    qr/\w+\s+(\w+)/, 
    "initialization dynamical variables");
  define_array_from_input($modelode, "psi_", "%C",
    qr/\w+\s+(\w+)/,
    "initialization couplings");
  define_array_from_input($modelode, "mfd_", "%M",
    qr/\w+\s+(\w+)/,
    "initialization meanfields");
  define_array_functions($modelode,
    "AUX", qr/^[aA]\s+(\w+)(\[[^\[\]]+\])*\s+(.*)$/,
    "initialization auxiliary functions");
  assign_output($modelode,
    "D\.*/DT", "f2_", $re_dxdt,
    "assign equations", "rhs");
  assign_output($modelode,
    "AUX", "aux_", $re_pace, 
    "assign auxiliary array pointer", "pointer");
  assign_pop_rate($modelode,
    "%DEATH", "myself_->death_rate",
    "assign particle death rate");
  assign_pop_rate($modelode,
    "%REPLI", "myself_->repli_rate",
    "assign particle replication rate");
  print $fch "\n    return GSL_SUCCESS;\n}\n\n";
}

sub print_ode_init_cond
{
  my $s = qq(int ode_init_conditions(const double t, double y_[], void *params_)
{
    par *myself_ = (par *)params_;
    double * pars_ __attribute__((unused)) = SIM->mu;
    double * aux_  __attribute__((unused)) = myself_->aux;
    double * expr_ __attribute__((unused)) = myself_->expr;
    double * y2_ = y_;
);
  print $fch $s;
  declare_iterators($modelode);
  declare_define_parameters($modelode,"ic");  
  declare_scalar_or_array($modelode,"E","parametric expressions");
  define_array_functions($modelode,
    "EXPR", qr/^EXPR\w*\s+(\w+)(\[[^\[\]]+\])*\s+(.*)$/i,
    "initialization parametric expressions");
  assign_output($modelode,
    "EXPR", "expr_", $re_pace,
    "assign parametric expression pointer", "rhs");
  assign_output($modelode,
    "INIT", "y2_", $re_pace,
    "assign initial conditions", "rhs");
  print $fch "\n    return GSL_SUCCESS;\n}\n\n";
}

# declare_iterators
# search for iterators [i=0:10]
# and declare a list of unique iterators
#   size_t i,j,k;
sub declare_iterators
{
	print $fch qq(    /* iterators */
);
	open(my $fh, '<', @_) or die "Could not open file '@_'. $!";
  my @iterators;
  my @unique_iters;
	while ( <$fh> )    
	{
		/^#/ and next; # ignore lines starting with '#'
		/^CONST/i and next; # ignore lines starting with 'C'
    if ( my @new_iter = (/\[\s*(\w+)\s*=\s*\d+\s*:\s*\d+\s*\]+/g)  )
    {
      push @iterators, @new_iter; # store iterator name
    } else 
    {
      next;
    }
	}
	@iterators = sort @iterators;
	my $iter = shift @iterators;
  push @unique_iters, $iter if length $iter;
  while ( @iterators )
 	{
		$iter = shift @iterators;
		push @unique_iters, $iter if $unique_iters[$#unique_iters] ne $iter;
	}
  if ( 0+@unique_iters )
  {
	  print $fch "    size_t " . join(', ', @unique_iters) . ";\n";
  }
  print $fch "\n";
}

# declare_define_parameters
# take a line of the form 
#   PAR mu VAL {attr} # comment
# and write model.c 
#   double mu = par_[<i>]; /* attr */ /* comment */
sub declare_define_parameters
{
  my ($fname,$func) = @_;
  print $fch "    /* parameters */\n";
	open(my $fh, '<', $fname) or die "Could not open file '$fname'. $!";
  my $i = 0;
	while ( <$fh> )    
	{
  	/^PAR/i or next;
    if ( my ($type, $varname, $rhs, $attr, $comment) = ( /$re_pace/ ) )
    {
      my ( $ctype ) = ( $attr =~ m/(int|long|double)/ );
      $ctype = "double" if not length $ctype;
      if ( $func =~ /ode/ )
      {
        if ($attr =~ /\bINIT/i or
            $attr =~ /\bIMPL/i )	
        {
          ++$i;
        } else
        {
          print $fch "    $ctype $varname = pars_[$i];";
          print $fch " /* $attr */" if length $attr;
          print $fch " /* $comment */" if length $comment; 
          print $fch "\n";
          ++$i;
        }
      } else
      {
        if ($attr =~ /\bINIT/i or
            $attr =~ /\bEVER/i )	
        {
          print $fch "    $ctype $varname = pars_[$i];";
          print $fch " /* $attr */" if length $attr;
          print $fch " /* $comment */" if length $comment; 
          print $fch "\n";
          ++$i;
        } else
        {
          ++$i;
        }
      }
    }
	}
  print $fch "\n";
  close($fh);
}

# TODO: handle definition of array in multiple declarations 
# declare_scalar_or_array
# takes a line EXPR array[i=0:10][j=0:15]
# and declare
#   double array[10][15];
sub declare_scalar_or_array
{
  my ($fname,$character,$descr) = @_;
  print $fch "    /* $descr */\n";
  open(my $fh, '<', $fname) or die "Could not open file '$fname'. $!";
  while ( <$fh> )    
 	{
		/^$character/i or next;   # match character or go to next line of file
    my ($type, $name, $rhs, $attr, $comment) = ( $_ =~ $re_pace );
    print $fch "    double $name";
    if ( my @it = ($_ =~ m/$re_iter/g) )
    {
      while ( @it )
      {
        shift @it; shift @it; 
        my $b = shift @it;
        print $fch "[$b]";
      }
    }     
    print $fch ";\n";
	}	
  print $fch "\n";
  close($fh);
}

sub define_array_from_input
{
  my ($fname,$rhs,$pat_char,$pat_name,$descr) = @_;
  open(my $fh, '<', $fname) or die "Could not open file '$fname'. $!";
  print $fch "    /* $descr */\n";
  my $ii = 0;
  while ( <$fh> )    
  {
    /^$pat_char/i or next;
    my ($type, $name, $dummy, $attr, $comment) = ( $_ =~ $re_pace ) or print "no pace found";  
    if ( my @it = ($_ =~ m/$re_iter/g) )
    {
      my $offset = qq();
      my $j = 0;
      while ( $j < (0+@it) )
      {
        my ($i, $a, $b) = @it[$j..$j+2];
        $j += 3;
        $offset = $offset . qq(    ); 
        print $fch $offset . "for($i=$a;$i<$b;++$i)\n";
        print $fch $offset . "{\n";
      }
      print $fch $offset . "    $name";
      $j = 0;
      while ( $j < (0+@it) )
      {
        my ($i, $a, $b) = @it[$j..$j+2];
        $j += 3;
        print $fch "[$i]";
      }
      print $fch " = " . "*(${rhs}++);"; # added
      # print $fch " = " . $rhs. "[$ii";
      # my $starp = qq( + );
      # my $iter_increment = 1;
      # $j = 0;
      # while ( $j < 0+@it )
      # {
      #   my ($i, $a, $b) = @it[$j..$j+2];
      #   $j += 3;
      #   print $fch "$starp$i";
      #   $iter_increment *= ($b-$a);
      #   $starp = qq/*(1+/;
      # }
      # print $fch qq/)/ x (@it/3-1);
      # print $fch "];"; 
      print $fch " /* $attr */" if length $attr;
      print $fch " /* $comment */" if length $comment;
      print $fch "\n";
      # $ii += $iter_increment;
      $j = 0;
      while ( $j < 0+@it )
      {
        print $fch $offset . "}\n";
        $offset = substr $offset, 0, -4;
        $j += 3;
      }
    } else
    {
      print $fch "    $name = *(${rhs}++)" . ";\n";
      # ++$ii;
    }
  }
  print $fch "\n";
  close($fh);
}

sub define_array_functions
{
  my ($fname,$pat_char,$pat_nameiter,$descr) = @_;
  open(my $fh, '<', $fname) or die "Could not open file '$fname'. $!";
  print $fch "    /* $descr */\n";
  while ( <$fh> )    
  {
    /^$pat_char/i or next;
    my ($type, $name, $rhs, $attr, $comment) = ( $_ =~ $re_pace );
    my $rhs2print;
    $rhs2print = strip_blanks($rhs) . ";";
    $rhs2print .= " /* $attr */" if length $attr;
    $rhs2print .= " /* $comment */" if length $comment;
    if ( $attr =~ /\bvect\b/ ) # don't loop, just evaluate the rhs
    {
      print $fch "    $rhs2print\n";    
    } else
    {
      if ( my @it = ($_ =~ m/$re_iter/g) )
      {
        my $offset = qq();
        my $j = 0;
        while ( $j < (0+@it) )
        {
          my ($i, $a, $b) = @it[$j..$j+2];
          $j += 3;
          $offset = $offset . qq(    ); 
          print $fch $offset . "for($i=$a;$i<$b;++$i)\n";
          print $fch $offset . "{\n";
        }
        print $fch $offset . "    $name";
        $j = 0;
        while ( $j < (0+@it) )
        {
          my ($i, $a, $b) = @it[$j..$j+2];
          $j += 3;
          print $fch "[$i]";
        }
        print $fch " = " . $rhs2print . "\n";
        $j = 0;
        while ( $j < 0+@it )
        {
          print $fch $offset . "}\n";
          $offset = substr $offset, 0, -4;
          $j += 3;
        }
      } else
      {
        print $fch "    $name = $rhs2print\n";
      }
    }
  }
  print $fch "\n";
  close($fh);
  
}


sub assign_output 
{

  my ($fname,$pat_char,$lhs,$pat_nameiter,
    $descr,$assign_rhs) = @_;
  open(my $fh, '<', $fname) or die "Could not open file '$fname'. $!";
  print $fch "    /* $descr */\n";
  my $ii = 0;
  while ( <$fh> )    
  {
    /^$pat_char/i or next;
    my ($type, $name, $rhs, $attr, $comment) = ( $_ =~ $pat_nameiter );
    my $rhs2print;
    if ($assign_rhs =~ /rhs/)
    {
      $rhs2print = strip_blanks($rhs) . ";";
      $rhs2print .= " /* $attr */" if length $attr;
      $rhs2print .= " /* $comment */" if length $comment;
    } else 
    {
      $rhs2print = $name;
    }
    if ( $_ =~ m/$re_scalar/ ) # scalar variable
    {
      print $fch "    *(${lhs}++) = " . $rhs2print; # added
      # print $fch "    ${lhs}[$ii] = " . $rhs2print;
      print $fch ";" if $assign_rhs !~ /rhs/;
      print $fch "\n";
      # ++$ii if /^(?:D|\w+\s)\s*(\w+\s*(\/DT)?\s*[^\[])/i;
      next;
    }
    if ( my @it = ($_ =~ m/$re_iter/g) )
    { 
      my $offset = qq();
      # my $starp = qq( + );
      # my $iter_increment = 1;
      my $j = 0;
      while ( $j < (0+@it) )
      {
        # $iter =~ /\s*(\w+)\s*=\s*(\d+)\s*:\s*(\d+)/;
        my ($i, $a, $b) = @it[$j..$j+2];
        $j += 3;
        $offset = $offset . qq(    ); 
        print $fch $offset . "for($i=$a;$i<$b;++$i)\n";
        print $fch $offset . "{\n";
      }

      print $fch $offset .   "    *(${lhs}++) = $rhs2print"; # added
      
      # print $fch $offset . "    ${lhs}[$ii";
      # $j = 0;
      # while ( $j < 0+@it )
      # {
      #   my ($i, $a, $b) = @it[$j..$j+2];
      #   $j += 3;
      #   print $fch "$starp$i";
      #   $iter_increment *= ($b-$a);
      #   $starp = qq/*(1+/;
      # }
      # print $fch qq/)/ x (@it/3-1);
      # print $fch "] = $rhs2print"; 

      # $ii += $iter_increment;
      if ( $assign_rhs !~  /rhs/ )
      {
        $j = 0;
        while ( $j < 0+@it )
        {
          my ($i, $a, $b) = @it[$j..$j+2];
          $j += 3;
          print $fch "[$i]";
        }
        print $fch ";"; 
      }
      print $fch "\n";
      $j = 0;
      while ( $j < 0+@it )
      {
        print $fch $offset . "}\n";
        $offset = substr $offset, 0, -4;
        $j += 3;
      }
      print $fch "\n";
    }
  }
  print $fch "\n";
  close($fh);
}

sub assign_pop_rate
{
  my ($fname,$pat_char,$lhs,$descr) = @_;
  open(my $fh, '<', $fname) or die "Could not open file '$fname'. $!";
  print $fch "    /* $descr */\n";
  while ( <$fh> )    
  {
    /^$pat_char/i or next;
    if ( my ($type, $rhs, $attr, $comment) = ( /$re_pop/ ) )
    {
      print $fch "    $lhs = " . $rhs . ";"; 
      print $fch " /* $attr */" if length $attr;
      print $fch " /* $comment */" if length $comment;
      print $fch "\n";
    }
  }
  close($fh);
}

sub set_low_rank_expansion
{
  open(my $fh, '<', @_) or die "could not open file '@_'. $!";
  my $nv = 0;
  my $s = qq(    /* update coupling terms psi,  O(NP^2) */
);
  print $fch $s;
  while (<$fh>) 
  {
    my ($varname, $rhs, $attr, $comment) = ( /$re_lrexp/ ) or next;
    if ( $rhs =~ /lrexp/ )
    {
      my ($var) = ( $attr =~ /var\s*=\s*(.*?)([;\s]|$)/ );
      my ($fun) = ( $attr =~ /fun\s*=\s*(.*?)([;\s]|$)/ );
      print $fch "    xxp_ = (double *)malloc(POP_SIZE*sizeof(double));\n";
      print $fch "    yxp_ = (double *)malloc(POP_SIZE*sizeof(double));\n";
      print $fch "    myself_ = SIM->pop->start;\n";
      print $fch "    i = 0;\n";
      print $fch "    while ( myself_ != NULL ) /* initialize xxp_ for lrkern */\n";
      print $fch "    {\n";
      print $fch "        mvar(\"$var\", myself_, (xxp_ + i));\n";
      print $fch "        myself_ = myself_->nextel;\n";
      print $fch "        ++i;\n";
      print $fch "    }\n";
      print $fch "    lrkern($fun, xxp_,yxp_, POP_SIZE);\n";
      print $fch "    myself_ = SIM->pop->start;\n";
      print $fch "    i = 0;\n";
      print $fch "    j = I_PSI($varname);\n";
      print $fch "    while ( myself_ != NULL ) /* set psixp */\n";
      print $fch "    {\n";
      print $fch "        myself_->psi[j] = yxp_[i];\n"; 
      print $fch "        myself_ = myself_->nextel;\n";
      print $fch "        ++i;\n";
      print $fch "    }\n";
      print $fch "    free(xxp_);\n";
      print $fch "    free(yxp_);\n";
    }
    elsif ( $rhs =~ /lrwexp/ )
    {
      my ($U) = ( $attr =~ /U\s*=\s*(.*?)([;\s]|$)/ );
      my ($V) = ( $attr =~ /V\s*=\s*(.*?)([;\s]|$)/ );
      my ($rank) = ( $attr =~ /rank\s*=\s*(.*?)([;\s]|$)/ );
      my ($var) = ( $attr =~ /var\s*=\s*(.*?)([;\s]|$)/ );
      my ($fun) = ( $attr =~ /fun\s*=\s*(.*?)([;\s]|$)/ );
      print $fch "    xxp_ = (double *)malloc(POP_SIZE*sizeof(double));\n";
      print $fch "    yxp_ = (double *)malloc(POP_SIZE*sizeof(double));\n";
      print $fch "    myself_ = SIM->pop->start;\n";
      print $fch "    i = 0;\n";
      print $fch "    while ( myself_ != NULL ) /* initialize xxp_ for lrkern */\n";
      print $fch "    {\n";
      print $fch "        mvar(\"$var\", myself_, (xxp_ + i));\n";
      print $fch "        myself_ = myself_->nextel;\n";
      print $fch "        ++i;\n";
      print $fch "    }\n";
      print $fch "    lrwpkern(I_EXPR($U), I_EXPR($V), $rank, $fun, xxp_,yxp_, POP_SIZE);\n";
      print $fch "    myself_ = SIM->pop->start;\n";
      print $fch "    i = 0;\n";
      print $fch "    j = I_PSI($varname);\n";
      print $fch "    while ( myself_ != NULL ) /* set psixp */\n";
      print $fch "    {\n";
      print $fch "        myself_->psi[j] = yxp_[i];\n"; 
      print $fch "        myself_ = myself_->nextel;\n";
      print $fch "        ++i;\n";
      print $fch "    }\n";
      print $fch "    free(xxp_);\n";
      print $fch "    free(yxp_);\n";
    }


  }
  $s = qq(    /* end - update coupling terms psi,  O(NP^2) */
);
  print $fch $s;
  close($fh);
}

# try to parse author information
# Author: J K Roller, George R R Martinet
#
# or
# 
# (not implemented)
# Author: JK Roller
#         GRR Martinet
sub find_authors
{
  my $re_author_keyword = qr/
  (?: Author|AUTHOR|author)s?      # word author(s)
  \s*:?\s+                         # followed by perhaps : 
  (.*)                             # followed by anything
  /x;
  my $re_fullname = qr/
  \G(\p{Lu}\p{Ll}+\b)[,.;]?\s* 
  /x;
  my $re_email = qr/
  \G([\w.]+@\w+\.[\w.]+\b)[;,]\s*   
  /x;
  my @authors;
  my @emails;
  open(my $fh, '<', @_) or die "Could not open file '@_'. $!";
  while ( <$fh> )    
  {
    my $author_line;
    if ( ( $author_line ) =  /$re_author_keyword/ )
    {
      while ( ( $author_line =~ m/$re_fullname/g ) ) 
      {
        push @authors, $1;
      }
      while ( ( $author_line =~ m/$re_email/g ) ) 
      {
        push @emails, $1;
      }
    }
  }
  close($fh);
 
  print $fch "/* Authors: " . join(' ', @authors) .  " */\n"; 
  print $fch "/* Emails: " . join(' ', @emails) .  " */\n"; 

}

sub strip_blanks
{
  my ($str) = @_; 
  $str =~ s/^\s*// if length $str;
  $str =~ s/\s*$// if length $str;
  return $str;
}

# -----------------------------------------------------------------
# SETTINGS/COMPILE/RUN
# -----------------------------------------------------------------


my $inputrcfile = $odedir . "/.inputrc";
open(my $finputrc, '>', $inputrcfile) or die "Could not open file '$inputrcfile'. $!";

print $finputrc q(# Key binding for readline
TAB: complete

# use a visible bell if one is available
set bell-style visible

# if there are more than 150 possible completions for
# a word, ask the user if they want to see all of them
set completion-query-items 150

$if odexp 
# odexp specific 
# increment parameter value and run
"\C-w": "q\C-j"
# increment parameter value and run
"\C-g": "+\C-j"
# decrement parameter value and run
"\C-h": "-\C-j"
# plot next variable
"\C-]": "]\C-j"
# plot previous variable
"\C-[": "[\C-j"
# plot next particle
"\M-\C-}": "}\C-j"
# plot previous particle
"\M-\C-{": "{\C-j"
# extend 
"\C-e": "e\C-j"
# repeat last command (\e[A history-search-backward arrow up)
"\C-y": "\e[A\C-j"
$endif
);

close($finputrc);

my $LDFLAGS = "-lgsl -lodexp";
my $CFLAGS =  "-Wall -Wno-gnu-statement-expression -pedantic -$opt_o";
system("gcc $CFLAGS $LDFLAGS $odedir/model.c -o model.out") == 0 
              or die "compiling failed: $?";
exec ("./model.out") or print STDERR "couldn't exec model.out: $!";


