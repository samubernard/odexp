.\" 
.TH ODEXP 1 "25/10/2018" "version 1.0" "Documentation" 
.SH NAME
odexp \- numerical solver for population-based system with gnuplot graphical output
.SH SYNOPSIS
.B "odexp "
[
.B \-p
.I parfile
] [
.I file
]
.SH DESCRIPTION
.B odexp 
is a command line program for numerical simulations and analysis of dynamical systems of particle populations.
Particles are defined by a system of ordinary differential equations (ODE), stochastic differential equations (SDE),
delay differential equations (DDE), of finite-difference equations (FDE). 
Particles can die and replicate. 

\fIodexp\fR parses and compiles the dynamical system defined in \fIfile\fR, and launches a command line tool
to explore its dynamics. See \fIEXAMPLES\fR for examples of a dyamical system file.
If \fIfile\fR is not given, \fIodexp\fR will take the dynamical system from the standard input.
When option \fB\-o\fR is present, system parameters, initial conditions and options are loaded from file \fIparameterfile\fR. 

\fIodexp\fR uses the \fIGNU Scientific Library\fR (GSL) for numerical integration of ODEs and DDEs and their
linear stability analysis. 
Solutions are plotted with \fIgnuplot\fR.

.SH OPTIONS

.TP 
.BI \-p " parfile"
Optional parameter file.

.SH USAGE 

.SS Line commands
Line commands can be entered at the \fIodexp\fR prompt. Multiple commands can be separated with && (does not
work when command expects a string argument).

.TP
.B ?              
Display this help.
.TP
.BR C^y 
Repeat last command.
.TP
.BR + ", " = ", " C^g 
Increment current parameter by a multiplicative factor \fBparstep\fR.
.TP 
.BR - ", " C^h
Decrement current parameter by a multiplicative factor \fBparstep\fR.
.TP
.BR ] ", " C^]    
Plot next variable on the y-axis (cyclic).
.TP
.BR [ ", " C^[ 
Plot previous variable on the y-axis (cyclic).
.TP
.BR } ", " C^}
Plot next particle on the y-axis (cyclic).
.TP
.BR { ", " C^{
Plot previous particle on the y-axis (cyclic).
.TP
.B >
Double the number of time steps. 
.TP
.B <
Halve the number of time steps.
.TP
.BI "# " dataset " " colx  " " coly 
Add to plot \fIcolx\fR and \fIcoly\fR from \fIdataset\fR.
.TP
.BI "! " filename   
Save the current plot to \fIfilename\fR. EPS format.
.TP
.BI $ id   
Print dataset for particle \fIid\fR. If \fIid\fR is missing, print stats dataset 
in population mode or particle in single mode.
.TP
.BI * " " [ msg ]        
Snapshot of current simulation and parameter values with optional \fImsg\fR.
.TP
.BR 0 ", " n 
Switch to/update normal plot. 
.TP
.BR 9 ", " b
Switch to continuation plot.
.TP
.BR 8 ", " j
Switch to range plot.
.TP
.B A 
Reset all axes to linear scale.
.TP
.BR a\fIus\fR ", " a\fIsu\fR
Set axis \fIu\fR={x|y|a} to scale \fIs\fR={l|n}, n for linear (normal) scale and l for log scale, \fIa\fR for all axes.
.TP
.B d              
Reload the parameter file. 
.TP
.B E
Decrease the time span by a factor 2.
.TP
.BI "e [" val ]
Increase the time span by a factor 
.I val 
(default factor = 2). 
.I val 
can be less than one.
.TP
.B f       
Fit data (not implemented).
.TP
.BI g cmd        
Send the command \fIcmd\fR to gnuplot.
.TP
.B h              
Toggle plot hold (on/off).
.TP
.B I              
Set initial conditions to default.
.TP
.B il            
Use the state of the system at t1 as initial conditions.
.TP 
.B in            
Loop through initial conditions. 
Set to I to revert to expression, enter to keep current initial condition.
.TP
.B is            
Set initial condition to steady state. 
Steady state must have been computed with \fBms\fR.
.TP
.B l@            
List all user-defined functions.
.TP
.B l%            
List population birth, replication and death rates.
.TP
.B la            
List all auxiliary variables (can be plotted).
.TP 
.B lc            
List all constant arrays.
.TP
.B ld            
Print file description (all lines starting with ##).
.TP
.B le            
List all parametric expressions.
.TP 
.B lf            
List all array files (nrows ncols filename)
.TP
.B li            
List all variables with initial conditions 
.TP
.B ll          
List file name and various information 
.TP
.BI lo " " [ optiontype ]         
List options that match \fIoptiontype\fR, or all options if \fIoptiontype\fR is missing
.TP
.B lp            
List all parameters. 
.TP
.B ls            
List steady states.
.TP 
.B lx            
List all equations and auxiliary variables.
.TP
.B mm            
Try to find all steady states.
.TP
.B mr 
Range over parameters. The active parameter takes values between.
.I par0 
and 
.I par1 
with multiplicative step 
.I rmstep 
and additive stepsr 
.IR astep . 
For each value, the system is
integrated over tspan and the min and the max of each variable is stored in the file 
.IR range.tab . 
If 
.I rric 
is 0, the initial conditions are set to the last state of the previous integration, 
otherwise, the initial conditions are set as usual.
.TP
.B ms            
Find a steady state with starting guess given by initial conditions.
.TP
.BI "o " filename  
Load parameters values and options from file \fIfilename\fR.
.TP
.BI "P " val        
Set current parameter to value \fIval\fR.
.TP
.BI p " " { ind | par } " " [ val ]     
Make parameter with index \fIind\fR or name \fIpar\fR the current parameter, and set its value to \fIval\fR.
When val is missing, the parameter value is unchanged.
.TP
.BR Q ", " q " " \fR[\fImsg\fR]        
Quit and snap with optional message \fImsg\fR 
.TP
.B R
Rerun the ODE system and update plot.
.TP
.B r
Repeat the last gnuplot command (replot)
.TP
.BI si " " { ind | var } " val"   
Set value of initial condition of variable with index \fIi\fR or name \fIvar\fR to \fIval\fR
.TP
.BI "sI " ind         
Revert variable \fIind\fR to expression
.TP
.B sl            
Change to last initial conditions, same as \fBil\fR but do not run simulation.
.TP
.BR so ", " set " " \fR{\fIind\fR|\fIvar\fR} " " \fIval\fR   
Set value of option with index \fIind\fR or name \fIvar\fR to \fIval\fR
.TP
.BI "st " ti " " val   
Set value of \fIti\fR to 
.I val 
(\fIti\fR = 0 or 1) 
.TP
.BI t " " [ t0 ] " t1"
Set time span from \fIt0\fR to \fIt1\fR. 
By default 
.I t0 
is not changed. 
Final time \fIt1\fR must be larger than \fIt0\fR.
.TP
.B u              
Toggle add curves to plot (on/off) 
.TP
.B ur              
Remove all curves and set curves off.
.TP
.BR v ", " 2 ", " 3 " " \fR{\fIi\fR|\fIx\fR} " " \fR{\fIj\fR|\fIy\fR} " " \fR[{\fIk\fR|\fIz\fR}]      
Set 2D/3D view, x-axis to index \fIi\fR (variable \fIx\fR), y-axis to \fIj\fR (variable \fIy\fR), 
and z-axis to \fIk\fR (variable \fIz\fR). 
Set variable to T or index -1 for time.
\fB2\fR takes only the first two arguments, and the \fB3\fR takes the three arguments
.TP
.B w 
List all particle states 
.TP
.BI x " " { ind | var }
Plot variable with index \fIind\fR or name \fIvar\fR on the x-axis
.TP
.BI y " " { ind | var }
Plot variable with index \fIind\fR or name \fIvar\fR on the y-axis

.SS Dyamical system keywords
A dynamical system is specified in a text file with lines starting with keywords for defining equations, parameters, options, etc. Keywords are case-insensitive. 

.TP
.BR PAR [ARAMETERS] 
Parameters. Must be numerical (double, int or long). Syntax:

.nf
PAR \fIname\fR \fIvalue\fR [ {\fIattribute\fR; ...} ] [ # \fIcomment\fR ] 
.fi

Parameters appear in the list of parameters. 
They can be modified from within odexp and can be ranged over. 
\fIname\fR must be a valid C variable name. 
\fIvalue\fR must be a constant number; by default a double, but can be 
an integer with attribute \fItype\fR = int or  \fItype\fR = long.
Parameters are declared in name value pairs, separated by commas  (,), or one parameter per line.
Parameters are common to all particles.
The prefix PAR is optional when one parameter is declare on a single line.

Examples 
.nf
PAR a 0.1, b 0.2

a 0.1 # ok
a 0.1, b 0.2 # not ok

PAR a 0.1 {unused} # attribute unused for unused parameters
PAR b 0.2 {inexpr} # attribute inexpr for parameters only used in expression
PAR c 0.3 {pop}    # attribute pop    for parameters only used in population-specific terms
PAR d 0.4 {every}  # attribute every  for parameters used in expressions, population and equations

PAR a 1 {type=int} # type integer. Warning this comment end at the comma: b is another parameter!, b 2.3 
.fi

Implicit initial condition. If \fIvar\fR is a dynamical variable, the declaration 

.nf
PAR var_0 0.5 
.fi

declares the parameter \fIvar_0\fR, sets it to 0.5 and implicitly declares the initial condition INIT \fIvar\fR 
\fIvar_0\fR.

.TP
.BR EXPR [ESSION]
Expressions. Expressions are function of the parameters. They cannot be modified. 
Syntax:

.nf
EXPR \fIname\fR \fIexpression\fR [ {\fIattributefR; ...} ] [ # \fIcomment\fR ] 
.fi

Expressions are particle-dependent. They are evaluated at the birth of a particle and are constant
for the lifetime of the particle. Use \fIATBIRTH\fR and \fIATREPLI\fR to specify particle-dependent expressions. 

Examples 

.nf
E c a*a
E rand_array[i=0:5] -1 + 2*rand01[i]
E is_ancestor ATBIRTH*1 + ATREPLI*0
.fi

.TP
.B AUX 
Auxiliary variables. Auxiliary variables depend on parameters, expressions and dynamical variables. 
Syntax:

.nf
AUX \fIname\fR \fIexpression\fR [ {\fIattributefR; ...} ] [ # \fIcomment\fR ] 
.fi

They are declared as Name Expression pairs, and must be scalars or one-dimensional arrays.
Auxiliary variables are useful to monitor quantities that depend on the dynamical variables. They can be 
plotted, and their values are recorded in the output file current.tab. 
Auxiliary functions are particle-dependent. They are evaluated at each time step.

.nf
A d sqrt(x+c)
A a[i=0:5] X[i]*X[i]
A norm_x sqrt(sum(a,5))
A norm_x2 dotprod(X,X,5)
.fi

.TP
.B D/DT
Dynamical variables. Dynamical variables are the dependent variables of the ODE system.
Syntax:

.nf
d\fIname\fR/dt = \fIrhs\fR [ {\fIattributefR; ...} ] [ # \fIcomment\fR ] 
.fi

Dynamical variable \fIname\fR is declared as d\fIname\fR/dt followed by = and the \fIrhs\fR of the equation

.nf
dx/dt = -a*x
.fi

.TP
.BR INIT [IAL]
Initial conditions. 
Syntax:

.nf
INIT \fIname\fR \fIexpression\fR [ {\fIattributefR; ...} ] [ # \fIcomment\fR ] 
.fi

Initial conditions can be numerical, or can be expression that depend on parameters or expressions.
For each equation D/DT, there must be an INIT with the corresponding \fIname\fR. 
If initial conditions are expressions, their values can be overruled or reset in odexp.

.nf
INIT x 1.0
INIT x b 
.fi

.TP
.BR OPT [IONS]
Options. Options can be preset. 

.nf
OPT x x1         # set x-axis to plot x1
OPT reltol 1e-3  # set ode solver reltol to 1e-3
.fi

.TP
.BR TIMES [PAN]
Timespan. Time span is an array of the form t0 ti ... t1 where t0 and t1 are the initial and final times. 
Intermediate values ti are stopping time, where the system is reset to initial condition. This is useful when systems
are discontinuous, and variable need to be reset at known timepoints.

.nf
TIME 0 10
TIME 0 10 20 50 100
.fi

.TP
.BR MAC [RO]
Define macro. Macro cannot be modified.

.nf
MACRO MY_PI 3.14
.fi

.TP
.BR SET
Set predefined constant. Useful to define system size.

.nf
SET N 100
.fi

.TP
.BR CONST [ANT]
Constant array. Must be numerical array. Constant arrays cannot be modified.
Constant arrays can be of any dimensions. Useful for arrays of small sizes. 

.nf
CONST MY_ARRAY[2][3] { {1.1, 1.2, 1.3}, {2.1, 2.2, 2.3} }
.fi

.TP
.BR FI [LE]
Constant array from file. Syntax:

.nf
FI \fIname\fR \fInrows\fR \fIncols\fR \fIfilename\fR 
.fi

where \fInrows\fR \fIncols\fR are the number of rows and columns in the file \fIfilename\fR.
\fIfilename\fR is a text file containing a space delimited array of doubles.

.TP
.B FUN
User-defined function.

.nf
FUN my_fun_name (x, y, z) = x*x+y+z 
.fi

is interpreted as 

.nf
double my_fun_name(double x,double y, double z) = { return x*x+y+z; } 
.fi

.nf
FUN mean(*x) = sum(x,LENTGH_X)/LENTGH_X 
.fi

is interpreted as 

.nf
double mean(double *x) { return sum(x,LENTGH_X)/LENTGH_X }
.fi

.nf
FUN myatan( x, *p) = ({ \
  double scale = *(double*)p; \
  x *= scale; \
  atan(x); \
})
.fi

is interpreted as 

.nf
double  myatan(double x, double *p)
{
    double scale = *(double*)p;
    x *= scale;
    return atan(x);
}
.fi

The function \fIsum\fR is a helper function (see below for a list of helper functions). 

.SS Population-specific declarations (%)

.TP
.B %BIRTH 
Particle (de novo) birth rate

.nf
%BIRTH 0.1 # set birth rate to 0.1 per unit time 
%BIRTH 1.0/(10 + \fIPOP_SIZE\fR) # set birth rate to a function of the total partice number \fIPOP_SIZE\fR 
.fi

.TP
.B %DEATH 
Particle death rate 

.nf
%DEATH 0.01 # constant particle death rate 
%DEATH \fIvar_death_rate\fR # set death rate to \fIvar_death_rate\fR 
.fi

.TP
.B %REPLI
Particle replication rate 

.TP
.B %C
Coupling term. 
This is of the form PSI[i] = 1/POP_SIZE*sum_{j=1}^POP_SIZE \fIphi\fR(x[j],x[i]), where \fIphi\fR is a function of two variables. The declaration is

.nf
%C PSI
phi(OY("x"),MY("x"))
.fi

The coupling term PSI take a value for each particle.

.TP
.B %M
Mean field. 
This is of the form MF = 1/POP_SIZE*sum(j=1) \fIphi\fR(x[j]), where \fIphi\fR depend only on one variable.

.nf
%M MF phi(MY("x"))
.fi

The mean field term in an average over the population, and take a single value.

.SS Macros

.TP
.B DWDT
Gaussian, uncorrelated white noise ~ N(0,1), as the derivative of the Wiener process. 
The stochastic differential equation 

.nf
dx/dt = -theta(x - mu)*x + sigma*DWDT
.fi

would have as a solution x(t) the Ornstein-Uhlenbeck process, centered at mu, with sigma a diffusion constant and
theta a dissipation rate constant.

.TP
.B POP_SIZE
Total number of particles. 

.TP
.B OY("var") " " (OE,OA)
Used in %C to iterate over all particles; var is a dynamical variable (Y), expression (E) or auxiliary variable (A).

.TP
.B MY("var") " " (ME,MA) 
Used in %C and %M to denote the current particle; var is a dynamical variable (Y), expression (E) or auxiliary variable (A).

.TP
.B SY("var") " " (SE,SA)
Value of the current particle's sister var. Useful to specify what happens when particle replicates. var is a dynamical variable (Y), expression (E) or auxiliary variable (A).

.TP
.B ATBIRTH 
logical variable indicating if the particle is just born.

.TP
.B ATREPLI 
logical variable indicating if the particle is replicating.

.TP
.B ISDAUGHTER 
logical variable indicating if the particle is the daughter. 
This is nonzero only at replication (
.B ATREPLI 
= 1). 
The daughter particle is the newly formed particle. 
At replication, the daughter particle is created from the mother particle by copy. 
Then, the mother particle is updated and becomes the sister particle. 
The daughter is then updated, and can refer to the sister particle with 
.B SE 
and 
.BR SY .

.TP
.B ISMOTHER 
logical variable indicating if the particle is the mother. 
This is nonzero only at replication (
.B ATREPLI 
= 1).

.TP
.B ID 
Particle ID

.SS Numerical and graphical options

See the list of options with line commdand \fBlo\fR.

.SS Functions acting on arrays
.TP
.BR \fIdouble\fR " " sum\fR(\fIdouble " " \fI*array\fR, " " \fIlong " " \fIlen\fR)
Sum the elements of the array \fIarray\fR of length \fIlen\fR.
Return the sum of the array.
.TP
.BR \fIdouble\fR " " sumstep\fR(\fIdouble " " \fI*array\fR, " " \fIlong " " \fIlen\fR, " " \fIlong " " \fIstep\fR)
Sum only the \fIstep\fR'th elements of the array \fIarray\fR of length \fIlen\fR.
.TP 
.BR \fIdouble\fR " " prod\fR(\fIdouble " " \fI*array\fR, " " \fIlong " " \fIlen\fR) 
Product of the elements of the array \fIarray\fR of length \fIlen\fR.
.TP
.BR \fIdouble\fR " " dotprod\fR(\fIdouble " " \fI*x\fR, " " \fIdouble " " \fI*y\fR, " " \fIlong  " " \fIlen\fR)
Scalar product of two arrays \fIx\fR and \fIy\fR of lengths \fIlen\fR. Returns the scalar product.
.TP
.BR \fIdouble\fR " " conv\fR(\fIdouble " " \fI*u\fR, " " \fIdouble " "  \fI*v\fR, " " \fIlong " " \fIlen\fR) 
convolution product between arrays \fIu\fR and \fIv\fR, each of length \fIlen\fR. Returns the convolution product.
.TP
.BR \fIdouble\fR " " minus\fR(\fIdouble " "  \fIx\fR, " "  \fIdouble " "  \fIy\fR)
Subtraction. 
Used with \fBsumxy\fR.
.TP
.BR \fIdouble\fR " " plus\fR(\fIdouble " "  \fIx\fR, " "  \fIdouble " "  \fIy\fR)
Addition.
Used with \fBsumxy\fR.
.TP
.BR \fIdouble\fR " " sumxy\fR(\fIlong " " \fIlen, " " \fIdouble " " \fI(*f)(double)\fR, " " \fIdouble " " \fI(*g)(double,double)\fR, " " \fIconst " "  \fIdouble " " \fI*x\fR, " " \fIconst " " \fIdouble " " \fIyi\fR)
Sum over j of \fIf\fR(\fIg\fR(\fIx_j\fR,\fIyi\fR)) 
.TP
.BR \fIdouble\fR " " linchaindelay\fR(\fIdouble " " \fIroot\fR, " " \fIdouble " " \fI*chain\fR, " " \fIsize_t " " \fIlink\fR, " " \fIdouble " " \fIdelay\fR, " " \fIsize_t " " \fIlen\fR)
\fIlink\fR'th element of a linear chain \fIbeta\fR*(\fIchain\fR[\fIlink\fR-1]-\fIchain\fR[\fIlink\fR]), (and \fIbeta\fR*(\fIroot\fR-\fIchain\fR[\fI0\fR]))

.SS Time delays
There is a shortcut to specify a delayed variable. 
If 
.I z 
is a dynamical variable, then

.nf
LAG \fIztau1\fR {root = z; mean = tau; len = 1000; init = 0.2}
.fi

defines the dynamical variable \fIztau1\fR as the delayed version of \fIz\fR 
with a linear chain of length 1000 and mean tau.
All intermediate variables, including \fIztau1\fR, have initial condition 0.2.

.SS Evaluating coupling terms in O(N)
Coupling term (%C) are evaluated by default in O(N^2) where N is the population size. 
When the attribute \fIexpan\fR is present in a coupling declaration, an order P Chebychev expansion  
is used to approximate the coupling function g given in the attribute \fIfun\fR over the variable given
in attribute \fIvar\fR. 
The Chebychev approximation is then used to compute the first P+1 coupling moments A_k

.nf
Ak = sum_{j=1}^N (xj)^k
g(xj-xi) = sum_{k=0}^P A_k phi_k(xi)  
.fi

Each moment is computed in O(N). The functions phi_k are computed in O(P^2). 
The resulting coupling terms can be computed in O(N*P^3).
The expansion method is therefore useful when N > P^3. For practical purpose, with P ~ 10, the method
can be faster if N > 1000. 
The P is precalculated at each evaluation based on abstol. 
P increases with max{|xj-xi|}, so that the method works better when the particles are concentrated. 

The coupling function g must be of the form g(u, *p) = gg(s*u) where the pointer p points to the scalar value s. 
Chebychev expansion is currently limited to coupling functions of the form g(xj-xi) for xi, xj scalars.

The following code calls the expansion method for the coupling term sin(xj-xi).
The auxiliary term TH is introduced to force the values of theta between 0 and 2 * PI. 

.fn
%C coupling 0.0 {expan; var = MA("TH"); fun = coupling_fun_sin}

AUX TH theta - ( (int) (theta/2/PI) * 2 * PI )

@ coupling_fun_sin(x, *p) = ({ \\
  double scale = *(double *)p; \\
  x *= scale; \\
  sin(x); \\
  })
.fi

.SS Stepping methods

.TP
.BR rk2 
GSL Explicit embedded Runge-Kutta (2, 3) method 

.TP
.BR rk4 
GSL Explicit 4th order (classical) Runge-Kutta 

.TP
.BR rkf45
GSL Explicit embedded Runge-Kutta-Fehlberg (4, 5) method.

.TP
.BR rkck 
GSL Explicit embedded Runge-Kutta Cash-Karp (4, 5) method. 

.TP
.BR rk8pd 
GSL Explicit embedded Runge-Kutta Prince-Dormand (8, 9) method.

.TP
.BR bsimp 
GSL Implicit Bulirsch-Stoer method of Bader and Deuflhard.

.TP
.BR fe 
Explicit Forward Euler with fixed time steps. Combined the macro DWDT, this is the Euler-Maruyama scheme.

.TP
.BR iteration 
Not an ODE stepper. The stepper assigns the RHS of the equation to the updated state variable.

.SH EXAMPLES
Here is an example of an odexp file for the Lotka-Volterra equations.

.RS
.nf
## file lotka.pop
## a simple nonlinear ODE system
#  all lines starting with ## are printed with the command ld

PAR a 0.2 # parameters can changed 
PAR b 0.3

dx/dt = x*(y - a) # equation on x
dy/dt = y*(b - x) # equation on y

INIT x 0.1 # initial condition for x
INIT y 0.2 # initial condition for y

TIMESPAN 0 10 # timespan is 0 to 10
.fi
.RE

To print the file current.plot formatted, use

.RS
hexdump -e '"%f " "%f " "%f " "\\n"' current.plot
.RE

.SH BUGS


